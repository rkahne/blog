{
    "collab_server" : "",
    "contents" : "---\ntags: ['Learning', 'R', 'Open Data']\ndate: 2017-07-28T13:14:46-04:00\ntitle: 'EDA and Basic Data Munging with Public Data'\ndraft: FALSE\nauthor: 'Robert Kahne'\n---\n\n## What are we about to do?\n\n* Learn the most important idioms for data munging in R\n* Apply them to an open data example\n* By the end, I hope you can use these skills to repeat this process with data you find\n\n## What Data Are We Using?\n\n* Kentucky Department of Education College and Career Readiness Data\n* Easily Found on their [website](http://applications.education.ky.gov/SRC/DataSets.aspx)\n\n## Step 1: Load Up Tidyverse and Read In Data\n```{r Loading..., message = F, warning = F, echo = T}\nlibrary(tidyverse)\n\nccr_data <- read_csv('./EDA_Munging_data/1516.csv')\n\nglimpse(ccr_data)\n\n```\n\n* What do we have here?\n    + Is this data *Wide* or *Narrow*? (or both?!?!?!)\n        - Wide data has columns for each variable\n        - Narrow data typically has a \"variable\" column and a \"value\" column and each variable is repeated multiple times.\n        - R very much prefers narrow data\n    + What columns seem important?\n        - Does this data have multiple columns that represent the same value?\n        - Are there columns that don't contain useful information?\n        - Consider your purpose for looking at the data, what story seems interesting and relevant?\n\n```{r Initial Munging, message = F, warning = F, echo = T}\n# Look at data\nglimpse(ccr_data)\n# Unique values in each column\nmap(ccr_data %>% filter(DIST_NAME == 'Jefferson County'), function(i) length(unique(i)))\n# Don't forget the glossary!\n# http://applications.education.ky.gov/SRC/Glossary.aspx\n\n## Looking at the data by county, selecting just the columns we are interested in\n\nccr_data_s <- ccr_data %>% \n  filter(DIST_NAME == 'Jefferson County') %>% \n  select(SCH_YEAR, SCH_NAME, DISAGG_LABEL, NBR_GRADUATES_WITH_DIPLOMA, NBR_CCR_REGULAR, PCT_CCR_NO_BONUS)\n\nglimpse(ccr_data_s)\n\n```\n\n## WTF JUST HAPPENED\n\n* The first thing we did was to load the `tidyverse`.  This gives use access to many of the most powerful data analysis packages.\n    + `dplyr` is a \"grammar of data manipulation\" and was written by Hadley Wickham.\n        - Four idioms in `dplyr` are the most important: `select`, `filter`, `mutate`, and `summarize`\n    + We've technically already used both `readr` with `read_csv` and also `tibble`.\n* `filter` - a subsetting function.  Takes column names and equivilencies as arguments.\n* `select` - a function for picking columns.\n    + `select` has a lot of helper functions, and negative values can be used.\n* `%>%` - the pipe. Linux people can guess what this means.\n    + Originally from the `magrittr` package. I have no idea what `magrittr` was supposed to do, but it gave use the pipe.\n    + When you see this, the data on the LHS becomes the first argument to the function on the RHS\n    + Once you get the hang of `%>%`, your life will change for the better\n    + A massive amount of R base functions have been rewritten so the data is the first argument.\n* *BONUS* `map` is from `purrr`.  It is a unique way to do iteration in R.  If we have time, I'll talk about it at the end.\n\n## Okay, So What Now?\n\n* Are there any `type` issues?\n* Let's explore our *narrow* columns to see if there are any inconsistencies.\n\n```{r More Munging, echo = T, message = F, warning = F}\nccr_data_s %>% glimpse()\nccr_data_s$SCH_NAME %>% unique() %>% sort()\n\n# Fix up some columns!\n\nlibrary(stringr)\nccr_data_t <- ccr_data_s %>% \n  mutate(\n    SCH_NAME = str_replace_all(SCH_NAME, '[[:punct:]]','') %>% trimws(),\n    SCH_YEAR = 2016,\n    NBR_GRADUATES_WITH_DIPLOMA = str_replace_all(NBR_GRADUATES_WITH_DIPLOMA, '[[:punct:]]','') %>% as.numeric(),\n    NBR_CCR_REGULAR = str_replace_all(NBR_CCR_REGULAR, '[[:punct:]]','') %>% as.numeric()\n  )\n\nglimpse(ccr_data_t)\n\n```\n\n## Mutate and `stringr`\n\n* Of all the `dplyr` functions, `mutate` is my favorite\n* `mutate` takes a column, applies a transformation to it, and either saves it back into the old column or creates a new column.\n    + Great for using iterators like the `apply` family or the `purrr::map` family.\n* `stringr` is another `tidyverse` package, but it needs to be loaded separately.\n    + There are a lot of basic string functions built into base R, but they don't have the data as the first argument, and can't be used with the `%>%`.\n    + It's PROBABLY a good idea to learn about the base R functions, but IMO, learning `stringr` is better.\n    + There are other, more powerful string function in `stringr` not available in base R.\n* We also used `as.numeric()` which is a casting function.  BE CAREFUL with these.\n    + If we hadn't pulled out the extra punctuation first, it would have cast the non-numeric data to `NA`.\n    \n## Narrow It Down\n\n* We've still got *Wide* data. Let's narrow it up!\n\n```{r Narrowing, echo = T, message = F, warning = F}\nccr_data_n <- ccr_data_t %>% \n    gather(key = Level, value = value, NBR_GRADUATES_WITH_DIPLOMA,NBR_CCR_REGULAR,PCT_CCR_NO_BONUS)\n\nglimpse(ccr_data_n)\n\n```\n\n## `Gather`, or, the most confusing thing in the world.\n\n* Back in the day, many people used a package named `reshape2`\n    + Many people still use it.  The best part was `reshape2::melt`, which made data narrow.\n* `tidyr::gather` is, in my mind, a better solution.  It's part of the `tidyverse` and make things more explicit.\n    + `gather` takes a _key_ and a _value_, which are NEW columns that will be created.\n    + Then, you pass it the columns you want to *gather* and those get placed into the _key_ column\n        - I told you this was confusing.\n    + There is a partner to `gather`, `spread`, which takes narrow data and makes it wide.\n    \n## Next Up, Listen for Tips!\n\n* Kris Stevens gave me this data, and told me that many of the \"District Total\" figures weren't correct.\n* Let's fix them up!\n\n```{r Adjusting, echo = T, message = F, warning = F}\nccr_data_n %>% \n    filter(Level == 'NBR_GRADUATES_WITH_DIPLOMA') %>% \n    group_by(DISAGG_LABEL) %>% \n    summarize('NBR_GRADUATES_WITH_DIPLOMA' = sum(value, na.rm = T)) %>% \n    left_join(\n      ccr_data_n %>% \n        filter(Level == 'NBR_CCR_REGULAR') %>% \n        group_by(DISAGG_LABEL) %>% \n        summarize('NBR_CCR_REGULAR' = sum(value, na.rm = T))\n    ) %>% \n    mutate(PCT_CCR_NO_BONUS = round(100 * (NBR_CCR_REGULAR / NBR_GRADUATES_WITH_DIPLOMA ))) %>% \n    gather(key = Level, value = value, NBR_GRADUATES_WITH_DIPLOMA,NBR_CCR_REGULAR,PCT_CCR_NO_BONUS) %>% \n    mutate(SCH_YEAR = 2016,\n           SCH_NAME = 'District Total') %>% \n    bind_rows(ccr_data_n) %>% View()\n```\n\n## Woof, that code is ugly.  Is there a better way?\n\n```{r Tidy, echo = T, message = F, warning = F}\naggregate_level <- function(df, col_head){\n  df %>% \n    filter(Level == col_head) %>% \n    group_by(DISAGG_LABEL) %>% \n    summarize(new_col = sum(value, na.rm = T)) %>% \n    rename_(.dots = setNames('new_col', eval(col_head)))\n}\n\nccr_tidy <- aggregate_level(ccr_data_n, 'NBR_GRADUATES_WITH_DIPLOMA') %>% \n  left_join(aggregate_level(ccr_data_n, 'NBR_CCR_REGULAR')) %>% \n    mutate(PCT_CCR_NO_BONUS = round(100 * (NBR_CCR_REGULAR / NBR_GRADUATES_WITH_DIPLOMA ))) %>% \n    gather(key = Level, value = value, NBR_GRADUATES_WITH_DIPLOMA,NBR_CCR_REGULAR,PCT_CCR_NO_BONUS) %>% \n    mutate(SCH_YEAR = 2016,\n           SCH_NAME = 'District Total') %>% \n    bind_rows(ccr_data_n)\n\n```\n\n## `group_by`, `summarize`, joins, binds, NSE, and functional programming\n\n* WHAT A LIST\n* If you've used SQL, you probably understand `group_by`.  \n    + When you group a column and then run an aggregation function, it aggregates PER GROUP.\n* `summarize` is one of those aggregation functions. \n    + `summarize` is kind of like mutate, but instead of creating a new column of the same length as the df, it summarizes the data. \n    + There are places where `summarize` is useful without `group_by`, but not many.\n    + The way we used `summarize` above, we got a number representing the sum of `value` by each `DISAGG_LABEL` .\n        - We could have switched the `group_by` to `SCH_NAME` and it would have given us the sum of `value` by each school.\n    + It's technically `summarise`, but this is America, dammit.\n* Joins are also something SQL users will be familiar with.\n    + Types: `left_join`, `inner_join`, `right_join`, `full_join`, `semi_join`, and `anti_join`.\n    + All types take two data frames, and typically a `by` argument, and sometimes a `suffix` argument.\n        - `by` takes a _vector_ that looks like ```c('lhs' = 'rhs')```\n        - If there are column names in common with LHS and RHS, the default suffix is '.x' and '.y', but you can override those.\n    + We are using `left_join`:\n        - \"return all rows from x where there are matching values in y, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned.\"\n    + The R documentation for joins is good if you aren't clear about which of these.  `anti_join` and `semi_join` are rare but cool.\n* Binds are way to bind together data frames.  They stack on top of each other.\n    + `bind_rows` and `bind_cols` are the `dplyr` way to do things.\n    + `rbind` and `cbind` are base R.\n    + As usualy, the tidyverse way is safer and more powerful.\n* Non-standard evaluation\n    + If you've got keen eyes, you've noticed that the arguments to the `dplyr` functions are never strings -- they are bare and unquoted.\n    + This form of evaluation is called \"standard evaluation\", and it's not great for programming. (Fine for analysis though).\n    + \"Non-Standard Evaluation\" is also present in `dplyr`.  It's all the functions with an underscore after them.  For example `rename_` (rename is another way to do `select`)\n        - Probably don't worry about knowing how to do this, but know it's there.\n* Functional Programming\n    + This is the heart of R -- building functions you can call later.\n    + Everything we've \"called\" so far is technically a function.  You can build your own!\n    + `function(x,y){}` would create a function that you could call with two inputs.\n    + Most of the functions I write are anonymous, but not always!\n    \n## OKAY SO WHAT NEXT\n\n* We've been working with one csv's worth of data so far, but the BoE makes several years available.  Let's combine them!\n* To do that, we will put all the code we've made so far into a function, and then bind all the data together using that function.\n\n```{r Combine, echo = T, message = F, warning = F}\n\ntidy_ccr <- function(df, county){\n  tidy_df <- df %>% \n    filter(DIST_NAME == county) %>% \n    select(SCH_YEAR, SCH_NAME, DISAGG_LABEL, NBR_GRADUATES_WITH_DIPLOMA, NBR_CCR_REGULAR, PCT_CCR_NO_BONUS) %>% \n    mutate(\n      # First Change\n      SCH_YEAR = map_int(SCH_YEAR, function(i){\n        case_when(\n          i == 20152016 ~ 2016L,\n          i == 20142015 ~ 2015L,\n          i == 20132014 ~ 2014L,\n          i == 20122013 ~ 2013L,\n          i == 20112012 ~ 2012L\n        )\n      }) %>% ordered(),\n      SCH_NAME = str_replace_all(SCH_NAME, '[[:punct:]]','') %>% trimws(),\n      NBR_GRADUATES_WITH_DIPLOMA = str_replace_all(NBR_GRADUATES_WITH_DIPLOMA, '[[:punct:]]','') %>% as.numeric(),\n      NBR_CCR_REGULAR = str_replace_all(NBR_CCR_REGULAR, '[[:punct:]]','') %>% as.numeric()\n    ) %>% \n    gather(key = Level, value = value, NBR_GRADUATES_WITH_DIPLOMA,NBR_CCR_REGULAR,PCT_CCR_NO_BONUS)\n  \n  aggregate_level(tidy_df, 'NBR_GRADUATES_WITH_DIPLOMA') %>% \n    left_join(aggregate_level(tidy_df, 'NBR_CCR_REGULAR')) %>% \n    mutate(PCT_CCR_NO_BONUS = round(100 * (NBR_CCR_REGULAR / NBR_GRADUATES_WITH_DIPLOMA ))) %>% \n    gather(key = Level, value = value, NBR_GRADUATES_WITH_DIPLOMA,NBR_CCR_REGULAR,PCT_CCR_NO_BONUS) %>% \n    mutate(SCH_YEAR = tidy_df$SCH_YEAR[1],\n           SCH_NAME = 'District Total') %>% \n    bind_rows(tidy_df)\n}\n\nbind_data <- function(county){\n  bind_rows(\n    read_csv('./EDA_Munging_data/1516.csv') %>% tidy_ccr(county),\n    read_csv('./EDA_Munging_data/1415.csv') %>% tidy_ccr(county),\n    read_csv('./EDA_Munging_data/1314.csv') %>% tidy_ccr(county),\n    read_csv('./EDA_Munging_data/1213.csv') %>% tidy_ccr(county),\n    read_csv('./EDA_Munging_data/1112.csv') %>% tidy_ccr(county)\n  )\n}\n\njefferson_data <- bind_data('Jefferson County')\n\n```\n\n# Now You Get It!\n\n* You get it, right?\n    + What does the `bind_data` function do?  Can you explain it?\n* I also made a change to the `SCH_YEAR` column, so that it work correctly.\n    + `case_when` is a sexy way to do `ifelse`.\n    + I also used another `map` function.\n* Okay, so let's take a look to make sure things aren't too weird.\n\n```{r Full Tidy, echo = T, message = F, warning = F}\nglimpse(jefferson_data)\njefferson_data$DISAGG_LABEL %>% unique()\njefferson_data$SCH_NAME %>% unique()\n\ntidy_ccr <- function(df, county){\n  tidy_df <- df %>% \n    filter(DIST_NAME == county) %>% \n    select(SCH_YEAR, SCH_NAME, DISAGG_LABEL, NBR_GRADUATES_WITH_DIPLOMA, NBR_CCR_REGULAR, PCT_CCR_NO_BONUS) %>% \n    mutate(\n      SCH_YEAR = map_int(SCH_YEAR, function(i){\n        case_when(\n          i == 20152016 ~ 2016L,\n          i == 20142015 ~ 2015L,\n          i == 20132014 ~ 2014L,\n          i == 20122013 ~ 2013L,\n          i == 20112012 ~ 2012L\n        )\n      }) %>% ordered(),\n      SCH_NAME = map_chr(SCH_NAME, function(i){\n        if(i == 'Dupont Manual High') 'duPont Manual High'\n        else if(i == 'Fern Creek Traditional High') 'Fern Creek High School'\n        else if(i == 'Fairdale High School MCA') 'Fairdale High School'\n        else str_replace_all(i, '[[:punct:]]','') %>% trimws()\n      }),\n      NBR_GRADUATES_WITH_DIPLOMA = str_replace_all(NBR_GRADUATES_WITH_DIPLOMA, '[[:punct:]]','') %>% as.numeric(),\n      NBR_CCR_REGULAR = str_replace_all(NBR_CCR_REGULAR, '[[:punct:]]','') %>% as.numeric()\n    ) %>% \n    gather(key = Level, value = value, NBR_GRADUATES_WITH_DIPLOMA,NBR_CCR_REGULAR,PCT_CCR_NO_BONUS)\n  \n  aggregate_level(tidy_df, 'NBR_GRADUATES_WITH_DIPLOMA') %>% \n    left_join(aggregate_level(tidy_df, 'NBR_CCR_REGULAR')) %>% \n    mutate(PCT_CCR_NO_BONUS = round(100 * (NBR_CCR_REGULAR / NBR_GRADUATES_WITH_DIPLOMA ))) %>% \n    gather(key = Level, value = value, NBR_GRADUATES_WITH_DIPLOMA,NBR_CCR_REGULAR,PCT_CCR_NO_BONUS) %>% \n    mutate(SCH_YEAR = tidy_df$SCH_YEAR[1],\n           SCH_NAME = 'District Total') %>% \n    bind_rows(tidy_df)\n}\n\njefferson_data <- bind_data('Jefferson County')\n```\n\n## Fixing the Weirdness\n\n* The `SCH_NAME` field was not consistent across the data, so we fixed it.\n    + We used an iterator, which is a little more advaced than we are going today (probably)\n\n## NOW WE'VE GOT TIDY DATA!!!!\n\n* Let's do some basic visualizations!\n\n```{r Viz, echo = T, warning = F, message = F}\nfacet_ccr <- function(df, lev){\n  ggplot(df %>% \n         filter(SCH_NAME != 'District Total',\n                Level == 'PCT_CCR_NO_BONUS', \n                DISAGG_LABEL == lev), \n       aes(x = SCH_YEAR, y = value, group = 1)) + \n  geom_smooth() +\n  geom_point() +\n  ggtitle('Percent College Career Ready by School, 2012 - 2016',\n          subtitle = lev) +\n  facet_wrap(~SCH_NAME) +\n  theme_minimal()\n}\n\nj<- bind_data('Jefferson County')\nf <- bind_data('Fayette County')\n\nfacet_ccr(j, 'All Students')\nfacet_ccr(f, 'All Students')\n\n```\n\n    ",
    "created" : 1501286698185.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1721193395",
    "id" : "C0A39B8E",
    "lastKnownWriteTime" : 1501290697,
    "last_content_update" : 1501290704188,
    "path" : "C:/Users/rkahn/Google Drive/R/blog/content/post/EDA_Munging.Rmd",
    "project_path" : "content/post/EDA_Munging.Rmd",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}